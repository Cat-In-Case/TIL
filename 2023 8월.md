# TIL
 
/*************          2023        *****************************/
##0802
### Unity
				AsyncSceneLoad할 때 주의사항
				-SceneManager.SceneLoad로 씬이 넘어갈 때, 해당 프레임 내에 AsyncSceneLoad를 하게 되면
					Async로드중인 씬으로 넘어가질 수 있음
				만약, 씬을 로드하고 다시 Async로 로드해야 할 경우 현재 불러오는 씬이 로드된 후 
				Async로 추가적인 씬을 로드


##0803 
###C#			
				JsonUtility.FromJson쓸때 JsonUtility.FromJson<Generic> 형태로 제너릭 클래스를 Json으로 Serialize가 가능
				
				IEnumerable를 이용하여 list또는 Array를 Select한 결과값을 사용 가능
				단, 복잡도가 내려가는 만큼 타인과의 공동 작업시 주석처리로 충분히 알려야됨


##0805
###Unity
				씬 주의사항 추가
				다른 씬(S2)으로 이동 후, 다시 이전 씬(S1)으로 이동 했을 때, 특정 오브젝트가 이벤트 발생 시 
				-Singleton에 Action으로 구독해놔도 다음 씬에 해당 오브젝트가 없으면 Null참조 발생
				-만약에 Action이 아니고 특정 필드(int)로 해당 오브젝트가 있는 배열(S1)에서 호출하면 가능
				-다만 배열의 등록이 Awake일때, 이벤트 호출은 Start에서 해야 안전
###C#
				List와 Array
				배열의 크기를 정적으로 할당 할 때, List는 Add로 넣어야 되서
				List[i] = object 로 바로 넣어지지 않음
				Array는 정적으로 할당 했을 때, 
				Array[i] = object 가 가능

##0806
###Unity 
				카메라 관련
				추가적인 카메라를 배치할 때, 전체적인 FPS는 줄어드는 것이 당연
				아무리 카메라의 Renderer, Rendering Layer, Render Distance를 최적화 해도 프레임은 떨어짐
				Editor상으로는 큰 차이를 보여도, 빌드 후에는 다르기 때문에 빌드 버전도 테스트 해야됨

				****주의사항
				2D 스프라이트 사용할 때, 블러처리되는 듯한 느낌이 있으면 Filter를 Point로

				Shader에서 Texture를 사용할 때, MainTex가 스프라이트 시트에서 가져온 것이면,
				MaskTex도 *같은 픽셀 위치*에 있어야 됨
				SpriteAtlas 사용 시, 자주 보이는 문제


##0807
###Unity
				Tweener를 사용할 때 추가적인 주의사항

				재사용 할 때, Pause와 SetAutoKill(false)를 해줘야 함

				만약 Transform을 사용하며, Tween이 중단될 수 있다면
				OnComplete에서 transform.position = EndValue 를 해주는 것이 좋음
				
				만약 Tween을 여러번 재사용하고 여러 트윈이 사용되는 경우
				Tweener nowTween을 사용하여 현재 사용중인 트윈을 제어할 수 있도록
				복잡한 트윈을 사용한다면 List<Tweener>에 추가하여 사용

				트윈의 값을 ChangeEndValue를 사용하여 바꿀 때, 연결된 2번 째 트윈에서
				ChangeStartValue를 1번째 트윈의 ChangeEndValue의 값으로 지정

			

##0808
###C#
				ValueTuple
				튜플은 힙에 메모리 할당이 있는 참조 유형

				튜플은 생성 후 읽기 전용 임으로 요소의 값을 변경할 수 없음



				Value튜플은 메모리가 스택에 저장되는 가벼운 개체 유형

				Value튜플은 구조체임으로 요소를 필드로 노출함

				즉, 성능과 유연성, 재사용성 측면에서 튜플보다 안정적임

				Value튜플의 요소 이름은 선언시 지정이 가능
				(string stringName, int intName) 이런식로 지정 가능

				Value튜플은 구조체 임으로 Null문제에서 비교적 자유로움

				Value튜플은 IEquatable을 지원함으로 == 연산자로 비교가 가능


				튜플을 ValueTuple로 변환 가능


##0809
###Unity 
				##0807 추가사항
				만약 List를 사용하여 사용중인 트윈을 중지시키는 경우
				Tween1과 Tween2가 연결되어 1의 OnComplete에서 Tween2가 실행될 때
				Tween1을 Pause를 하더라도 Complete를 시켜 Tween2가 실행되게 한 후 Tween2를 Complete시켜야
				안전하게 두 트윈이 중지됨

				SetAutoKill(false) 상태에서 Tween1.Restart()를 실행 시키면 OnPlay()가 호출됨
				따라서 Tween1.Complete(() => Tween2.Restart())일 때, Tween2의 isPlaying()을 체크하면
				true가 나오는걸 알 수 있음


##0812
###UNity_HLSL
				Vertex 부분에서 Texture2D를 사용하려면 SAMPLE_TEXTURE2D가 아닌
				SAMPLE_TEXTURE2D_LOD로 사용


##0813
###Unity
				AudioSource에서 MixerGroup을 변경하는 경우
					SFX때문에 MixerGroup을 변경해야 되는 경우에는 audiosource.outputAudioMixerGroup을 변경
					masterMixerGroup = mixer.FindMatchingGroups(string.Empty)를 통해 MasterMixer의 모든 Group을 가져올 수 있음

					string.Empty가 아닌 Group의 이름을 넣으면 특정 Group만 가져올 수 있음

					가져오는 Group의 순서는 Editor의 Audio Mixer Window에 나타난 순서대로


					FindMatchingGroups를 통해 지정된 이름의 믹서를 하나하나 가져오는 것보다
					string.Empty로 모든 배열을 가져와 const int로 특정 믹서의 번호를 배열에서 가져오는 것이 빠름

					Group의 Attenuation에 우클릭으로 Parameter Expose 가능

					특수 효과도 Parameter Expose 가능


##0814
###C#

#### 플레이어 또는 적의 WorkingTask   1
				순서대로 일을 처리하도록 하는 시스템
				WorkingTask Class에 처리할 일을 추가
				List<WorkingTask>를 사용하여 각 객체마다 총합 WorkingTask를 관리
				enum WorkingState를 통하여 현재 처리중인지 확인

				처리중인 경우 WorikingTask.isCompleted를 통해 처리가 끝났는지 확인
				WorikingTask는 Coroutine에서 WaitUntil(() => WorkingTask.isCompleted == false) 



				WorikingTask내부에 포함되는 내용

				* 완료 여부 : isCompleted
				*우선순위 : Priority 
				
				*WorikingTask내의 작업을 Action<T>로 할 것인지, abstract class로 할 것인지 정해야 함

				-Action<T> : WorkingTask.isCompleted = true 문장이 포함되어야 함
							isCompleted를 고려하면 WokingTask 클래스에 isCompleted = true를 하는 함수 
									Complete()를 추가하여 Action<T>의 마지막에 Complete를 실행하도록 해야 함
							ex) 
								WorkingTask workingTask = new WorkingTask();
								Action<Action> task;
								task = tasking(woringTask.Complete);
								woringTask.task = this.task;
								///
								tasking(Action complete)
								{
									//doSomething
									complete?.invoke();
								}
									

				-abtract class : 각 Task마다 class의 종류가 다름

				ex)			
					class move : Task
					{	}
					class Anim : Task
					{		}
				
					WorkingTask.task = new Anim();


##0816
###C#
				Array의 Elements를 탐색할 때는 For Loop보다 Array.Find가 더 빠름
				Slice를 사용하면 Element가 있건 인덱스가 빈 공간으로 만들어지고
				전체 Array의 길이가 줄어듬

				길이를 유지하고 배열을 삭제하는 방법으로는 delete operator를 사용하여 해당 인덱스의
				Element를 null 또는 0으로 만들면 됨


##0817
###HLSL

				Custom Lightmap 적용 방법


				#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

				float2 lightmapUV : TEXCOORD1;
				float3 tangentWS : TEXCOORD2;
				float biTangent : TEXCOORD3;


				o.lightmapUV = i.lightmapUV * _LightMap_ST.xy + _Lightmap_ST.zw;
				o.tangentWS = TransformObjectToWorldDir(v.tangent.xyz);
				o.biTangentWS = cross(o.normalWS, o.tangentWS) * v.tangent.w;

				//URP용
				SampleSHVertex(half3 normalWS)

				//더 찾아봐야됨
                half3 lightmap = (DecodeLightmap(SAMPLE_TEXTURE2D(unity_Lightmap, i.lightmapUV)));

                float3 shl = ShadeSH9(float4(i.worldNormal,1));
                f.light.rgb = (_AmbColor.rgb + shl*2 + lightmap) * color;

				핵심은 diffuse에 half3 lightmap가 곱해져야 된다는 것

##0818
#### 플레이어 또는 적의 WorkingTask   2