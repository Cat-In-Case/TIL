# TIL
 
##0902
###Unity
			Tween 주의사항
			Tween을 재사용 할 때, 2개 이상의 Tween이 연결된 경우
			Tween1.OnPlay(() => Tween2.Restart())를 사용해도 된다

			만약 Tween의 Value를 변경할 경우 (ex: move)
			Tween1.ChangeEndValue(new Vector3(10, 0, 0));
			Tween2.ChangeStartValue(new Vector3(10, 0, 0))
					.ChangeEndValue(new Vector3(20, 0, 0));
			
			Tween2의 StartValue도 갱신해줘야 된다
			
			이유
			Tween1.DoMove(Transform.position + 64f, 1f);
			Tween2.DoMove(Transform.position + 128f, 1f);
			로 Initial되었을 때

			Tween1을 Initial할 때 Start가 Transform.position, End가 Transform.position + 64f
			Tween2가 Start가 Transform.position + 64f, End가 Transform.position + 128f로 
			설정되어 있기 때문에
			Tween2의 경우에는 Start로 바꿔줘야 된다


##0903
###C#
			Dictionary의 Json 저장
			Dictionary는 Json으로 Parse가 불가능하다
		    따라서 Dictionary의 Key, Value를 하나의 Class로 묶고 이 Class를 배열화하여 저장해야된다

			TKey와 TValue는 Generic
			public class DicToClass<TKey,TValue>
			{
				public TKey key;
				public TValue value;
			}

			저장용 클래스
			public class JsonDictionaryList<TKey, TValue>
			{
				List<DicToClass<TKey,TValue>> data;

				public class JsonDictionaryList<TKey, TValue>(JsonDictionaryList<TKey, TValue> data)
				{
					this.data = data;
				}
			}

			위의 클래스로 key, value를 따로 받아올 수 있는 제네릭 클래스(Generic Class)를 만든다

			아래는 ToJson에 해당되는 스크립트
			//정해진 길이가 없기 때문에 List를 사용
			List<DicToClass<TKey,TValue>> list = new List<DicToClass<TKey,TValue>>();
			DicToClass<TKey,TValue> save;
			foreach(TKey key in (Dictionary<TKey, TValue>) dictionary)
			{
				save = new DicToClass<TKey,TValue>();
				save.key = key;
				save.value = dictionary[key];

				list.Add(save);
			}

			JsonDictionaryList<TKey, TValue> saveData = new JsonDictionaryList<TKey, TValue>(list);
			
			JsonUtility.ToJson(saveData);


			아래는 FromJson에 해당되는 스크립트
			JsonDictionaryList<TKey, TValue> loadData = JsonUtility.FromJson<JsonDictionaryList<TKey, TValue>>(savedDataString);
			List<DicToClass<TKey,TValue>> list = loadData.data;

			Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();
			int length = list.Count;
			for(int i = 0; i < length; i++)
			{
				DicToClass<TKey,TValue> saved = list[i];

				dictionary[saved.key] = saved.value;
			}
			

##0906~0907
###Unity
			최적화 문제

			-Dynamic Batching
				스태틱 배칭과 다르게 런타임상에서 배칭 처리
				Vertex(정점)의 수가 제한적임(300까지)
				Skinned Mesh의 경우 Vertex Shader에서 WorldSpace로의 변환 과정 중,
					다이나믹 배칭이 사용되면 CPU에서 연산이 이루어지기 때문에 효율저하
				MultiPass Shader에서 Batching x
				
				Trasnform을 미러링(ex scale.x = -1)한 오브젝트 Batching x

			-Static Object
				움직이지 않는 정적인 오브젝트 ex) Wall, House 등 Position이 바뀔리가 없는 오브젝트
				--Batching Stactic
					Project Setting - Player - Static Batching 활성화
					오브젝트의 이동, 회전, 스케일 불가능
					**오브젝트를 합쳐서 내부적으로 하나의 메시로 만들어 주기 때문에
						해당 메시로 여러개의 오브젝트를 만들면 합친 만큼 추가 메모리가 필요
						런타임에 추가하게되면 StaticBatchingUtility.Combine()를 사용해야 배칭처리


			-DisableBatching
				만약 배칭 오버헤드가 더 크다고 판단되면 쉐이더에서 강제설정
				Tags { "DisableBatching" = "True" }

			-Mesh Renderer or Sprite Renderer의 비활성화
				필요할 때만 활성화해야 함

			-SpriteAtlas
				만약 Shader에서 MaskMap등의 추가 데이터가 사용되지 않는 Texture의 경우
				SpriteAltas에 추가하여 최적화
			

			-In Shader
			만약 특정 오브젝트가 단순히 쉐이더의 색상만 다를 경우 통일된 Material을 사용
			SpriteRenderer에서 Color부분 => float4 color :COLOR;로 가져와 I.color로 사용 가능

			-SpriteRender의 경우
			Texture의 Vertex를 FullRect로 설정한다 => Vertex의 수가 줄어든다


			-Occulusion Culling
				--Frustum Culling
				--Occulusion Culling
				폐쇠적인 환경의 씬에서는 매우 효율적, 야외 등의 개방적 공간에서는 효율성이 떨어진다
				SmallestOccluder의 값이 작을수록 정밀도가 올라간다
					=> 다만 정밀도가 올라갈수록 연산 오버헤드 및 데이터량의 증가가 있다

			-GPU Instancing
				적은 수의 드로우 콜을 사용하여 동인한 Mesh의 복제본을 한번에 렌더링
				효율적인 오브젝트 ex) 나무, 건물, 풀, 돌 => 반복적으로 여러번 사용됨
				같은 메시를 사용하더라도 컬러, 스케일 변화가 가능함
				추가적인 별도의 Mesh를 생성 x => 오버헤드 적음



##0908
###Unity
			CreateMeshBox 코드

				x => x축
				y = > y축
				


				for(int i; i< x; i++)
				{
					for(int k = 0; k < y; k++)
					{
						GameObject piece = new GameObject();

						MeshFilter filter = (MeshFilter)piece.AddComponent<MeshFilter>();
						MeshRenderer meshRenderer = (MeshRenderer)piece.AddComponent(typeof(MeshRenderer));
						Mesh uMesh = piece.GetComponent<MeshFilter>().sharedMesh;

						Vector3[] vertices = new Vector3[4];
						int[] triangles = new int[6];

						vertices[0] = new Vector3(size.x / x * i - size.x * 0.5f , size.y / y * k - size.y * 0.5f);
					    vertices[1] = new Vector3(size.x / x * i - size.x * 0.5f, size.y / y * (k+1) - size.y * 0.5f);
					    vertices[2] = new Vector3(size.x / x * (i+1) - size.x * 0.5f, size.y / y * (k+1) - size.y * 0.5f);
					    vertices[3] = new Vector3(size.x / x * (i+1) - size.x * 0.5f,  size.y / y * k - size.y * 0.5f);

					    triangles[0] = 0;
					    triangles[1] = 1;
					    triangles[2] = 2;

						triangles[3] = 0;
					    triangles[4] = 2;
					    triangles[5] = 3;

						Vector2[] uv = new Vector2[4];  //0~1

						uv[0] = new Vector2(_i / x, _k / y);
						uv[1] = new Vector2(_i / x, (_k + 1) / y);
						uv[2] = new Vector2((_i + 1) / x, (_k + 1) / y);
						uv[3] = new Vector2((_i + 1) / x, _k / y);

						uMesh.vertices = vertices;
						uMesh.uv = uv;
						uMesh.triangles = triangles;

						filter.mesh = uMesh;

						meshRenderer.material = mat;
					}
				}

##0909
###Unity
			Frustum Culling
			물체가 카메라 뷰의 외부에 있을 경우 FrustumCulling이 자동으로 적용된다
			OnBecameVisible, OnBecameInvisible은 이 때 동작하는 함수

			즉, 뷰의 외부에 있을 때, 비활성화 등의 작동이 필요할 때 사용