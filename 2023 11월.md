# TIL
 
##1101
###10월에서 이어서
	
			Inventory와 BuildSystem은 동시에 열 수 없음
			서로 return으로 함수를 강제로 끝냄

			BuildSystem의 경우 QuickSlot 선택 시 비활성화 됨
			반대로, Quickslot상태에서 BuildSystem누르면 Quickslot이 비활성화 됨


##1102
			JsonConverter
			-JsonUtility는 Dictionary를 저장하지 못함
			-CustomSerialzableDictionary에 FromJson, ToJson을 만들어도 됨, 하지만 에셋을 활용하는 쪽으로

			만약에 revised Class가 Dictionary에 value로 사용된 경우 문제가 발생
				- class BaseObject
				- class SubObject1 : BaseObject
				- class SubObject2 : BaseObject
				위의 데이터를 저장하는 경우
				Dictionary<string, BaseObject>를 사용하게 되는데 이 때, 문제가 발생함
					-- data = JsonConvert.SerializeObject(persistentDic, Formatting.Indented);
				data를 보면 Revised class의 데이터도 직렬화 된 것을 알 수 있음
				하지만 DeserializeObject시에 복원되는 데이터는 typeof로 확인해보면 전부 BaseObject
				따라서 아래의 솔루션이 필요

				SerializeObject, DeserializeObject에는 JsonSerializerSettings settings를 추가할 수 있음
				JsonSerializerSettings에 TypeNameHandling = TypeNameHandling.All를 추가하여 직렬화, 역직렬화를 하면 
				아래와 같이 직렬화되어 Type이 저장된 것을 알 수 있음
	"Building": {
		"$type": "PersistentDatas, Assembly-CSharp",
		"data": {
			"$type": "System.Collections.Generic.List`1[[ObjectPersistentData, Assembly-CSharp]], mscorlib",
			"$values": [
				{
				"$type": "BuildingPersistentData, Assembly-CSharp",
				"objectType": 3,
				"objectID": 0,
				"gridPos": {
					"$type": "UnityEngine.Vector3Int, UnityEngine.CoreModule",
					"x": -5,
					"y": 4,
					"z": 0,
					"magnitude": 6.40312433,
					"sqrMagnitude": 41
					},
				"Attributes": ""
				}
			]
		}
	}  


			만약의 get only property를 사용한 경우
				-필드가 Private상태 임으로 읽을 수 없음
					-- 필드의 Attribute로 [JsonProperty] 추가
					-- public 상태 Property에는    [JsonIgnore] 추가
							--- 양쪽에 추가해 두면, 읽기전용 프로퍼티 부분은 저장되지 않고 필드만 저장

##1104
			작성한 gif와 소스코드의 일부를 블로그에 업로드
			https://blog.naver.com/afkmaster000/223255974587
			
			위의 JsonConverter와 Encryption 관련 소스코드
			gif는 PersistentManager의 저장 및 복원 과정

			미완료 부분
				-각 Elevation의 Building 상태 부분
				-TimeManager를 통한, 복원 이후의 시간경과 체크
				-PlacementDictionary에서 GridPos부분 초기화 관련
				-Farmland의 타일맵이 변경되면 저장이 되어야 하는데 아직 없음


##1108
			Interact 구현
				-각 오브젝트에는 Interact()가 공통으로 있음 => 차후에 interface IInteract를 통한 public virtual void Interact로 묶을 예정
				-Interact의 거리를 제한하는 코드 추가
					Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
					float distance = Vector2.Distance(playerPos, mouseWorldPos);
					if (distance > limitDist) 
					{
						return; //너무 멈
					}


			LayerCheck를 통한 Interact => NameToLayer부분을 Caching 해야함
	        if (hit.transform.gameObject.layer == LayerMask.NameToLayer("PlaceableObject"))
			{
				PlaceObject gb = hit.transform.GetComponent<PlaceObject>();
				gb.Interact();
			}
			else if (hit.collider.gameObject.layer == LayerMask.NameToLayer("Plant"))
			{
				hit.transform.GetComponent<PlantObject>().Interact();
			}
			else if (hit.transform.gameObject.layer == LayerMask.NameToLayer("BuildingObject"))
			{
				BuildingObject gb = hit.transform.GetComponent<BuildingObject>();
				gb.Interact();
			}

			PersistentManager
				-1104에서 완성된 버전에 Tile변경 사항을 저장하는 기능 추가

			Storage 구현
				-PlayMouseAction => PlaceableObject Layer의 GameObject를 Raycast => hit.collider.GetCompoenent해서 Interact() 
				-PersistentData 내부의 string Attribute에 List<SlotSaveData>를 JsonConvert.SerializeObject로 저장
				-PersistentManager에서 복원 시(Restore)에서 Attribute로  List<SlotSaveData>를 복원

			StorageUI 구현
				-Storage의 경우, 같은 오브젝트가 여러개 설치됨 => WorldCanvas하는거 보다 통일된 UI
				-Interact 시, SetStorage(ref Storage storage, ref List<SlotSaveData> saveData)가 호출됨
				-saveData는 창고 오픈 시, 아이템 데이터 읽고 UI가 가진 Slot의 Sprite와 id, amount, filled를 변경해줌
				-창고 Close 시, getted_saveData의 데이터를 변경된 Slot들의 saveData로 교체 
						=>  getted_saveData.SetData(saveData[i].id, saveData[i].amount);

##1110
			https://blog.naver.com/afkmaster000?Redirect=Write&categoryNo=17
			Inventory Sort에서 같은 ID의 아이템끼리 합쳐지지 않는 문제 해결
			ElevationObject의 PersistentManager 작동 gif 

			https://blog.naver.com/afkmaster000/223261704833
			Storage와 PersistentManager를 통한 저장 및 복원 gif