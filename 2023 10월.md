# TIL
 
##1001
###Unity
			ItemDataBase 작성
			ItemDB에 아이템 목록을 작성할 때, Class를 기준으로 넣는 경우
			
			Item.cs
			public class Item : ScriptableObject
			{
				[SerializeField] private int _id;
				public int id { get { return _id; }}
			}

			TileItem.cs
			public class TileItem : Item
			{
				[SerializeField] private TileBase _tile;
				public TileBase tile { get { return _tile; }}
			}

			ItemDB.cs
			public class ItemDB : ScriptableObject
			{
				[SerializeField] private List<Item> _db = new List<Item>();

				public void GetItem(ref int id)
				{
					float index = id;

					//추가적인 서칭 로직
					*
					*
					*

					return _db[index];
				}
			}

			위의 코드로 작성할 경우
			Item과 TileItem의 서로다른 ScriptableObject를 만들 수 있으며,
				ItemDB의 _db에는 둘다 추가할 수 있다

			추가사항
			TileBase 비슷하게 RuleTile도 TileBase에 넣고 typeof로 RuleTile인지 boolCheck


##1003~100(10)	지속적으로 추가
###Unity
			PlaceSystem

			Grid기반
			Mask의 경우 TileMap에 Raycast를 Hit시켜 체크
			-MouseGridPos와 RaycastedGridPos가 있음
			-둘이 불일치하면 불가능한 구역

			만약, 손에 아이템이 있으면
			-손에 있는 아이템이 삽인 경우 => 선택된 Tile의 종류를 체크 => 삽으로 팔 수 있는가?
			-손에 있는 아이템이 곡괭이인 경우 => 선택된 PlaceObject의 종류를 체크 
			-손에 있는 아이템이 괭이인 경우 => 이미 아이템이 배치되어 있는가? => 선택된 Tile이 Mask에 포함되는가? 
								=> Dirt가 맞는가? => 물이 뿌려져 있는가?


			배치에는 여러 종류가 필요
			구분된 배치종류

			다중 레이어로 배치가능 구역 구분
			- Grid--TileMap으로 Farmable, Placeable 구분
			- 단, Farmable의 경우 DirtTile일 때, FarmlandTile로 바꾸는 경우 사용 x
			- Placeable은 각 맵마다 다른 데이터를 사용

			따라서 현재 Mask는
			*Placeable
			*Farmland
			**Fishing ***=> 낚시의 경우 Shovel로 WaterTile로 바뀌는 경우 Mask를 사용하면 바뀐 타일에서 낚시 불가능

			Tile
			-다른씬에 넘어가도 유지필요성 x
			-씬 로드시 SetTile해도 됨
			-특정 타일만 바꿀 수 있을 떄, 바꾸려는 Tile이 바뀔 TileItem에 정보가 있어야됨
				--TileManger에서 TileDataBase를 추가하는 방법도 있음

			Plants
			-다른 씬에 넘어가도 유지되야 함
				--시간에 따른 성장 때문에
				--씬이 Release되어도 DontDestroy에서 동작
				--수확할 때
					---Raycast로 체크, PlaceableObject와 다른 레이어지만, 동시에 처리
			-반드시 농지(farmland)위에 만들어야 함
				--타일에 대한 체크가 필요
				--선택된 타일이 Farmland인지 체크 + 이미 Plant가 있는지 체크 
			-나무의 경우 3X3등의 넓은 타일 사용가능
			-물뿌리개를 들고있는 경우 Farmland기준으로 체크


			PlaceableObject
			-다른 씬에 넘어가도 유지되야 함
				--제작하는 오브젝트가 있음
				--씬이 Release되어도 DontDestroy에서 동작
			-최대 숫자 제한이 필요
			-메모리상 차지하는 공간의 크기도 고려되어야 함 => DontDestroy에 있기 때문


			오브젝트의 저장
			-오브젝트의 종류에 따른 다른 저장
			-Placeable의 경우 크기가 각색이기 때문에, GridPos와 ItemID 또는 ObjectID만 저장
				--로드시 배치할 때와 같은 로직으로 배치 => 같은 결과
				--그리드는 1칸의 중앙은 Vector2(.5f, .5f)가 더해져야 됨


####	추가사항
			Inventory, ItemSlot, PlayerHand, QuickSlot, Cursor와의 연결

			PlayerHand의 구조를 변경해야 함
			-QuickSlot에서의 아이템 선택과 Inventory에서의 아이템 선택은 다름
			-QuickSlot은 SelectSlot 시, ItemType 체크로 PlacementSystem 호출
				--UpdatePosition(DetectGridPos)와 GetMouseButtonDOwn은 Placement가 아닌
					PlayerHand에서 처리됨 => Update할 때, 순서 꼬임으로 인한 오류 방지
				--PlacementSystem에서 Update가 호출되면 안됨

			-Inventory에서 GrabItem일 때와, QuickSlotSelect에서 사용하는 함수는 다르게
				--Inventory에서는 ItemTypeCheck에서 Weapon, Potion은 체크하지 않음
				--다만, QuickSlot에서 선택 후, 클릭하면 작동해야 함
				--따라서 ItemDropCheck가 아닌 ItemUseCheck

			-QuickSlot에서 선택 시, Placement가 바로 활성화 가능하게
				--bool IsInventoryOpen에 따른 차이
					---QuickSlotSelect할 때 ItemType을 가져올 때, Hand의 ItemType도 바꿈
					---ItemType에 따라 Cursor를 변경 + Raycast 또한 변경
				
			-공격 시, PlayerHand에서 체크를 해야하는가
				--ItemType이 Resource 일때, Raycast로 InteractObject 체크
						좌클릭 시, 아이템 추가 
						우클릭 시, Interact
				--Weapon일 때, Attack체크
						좌클릭 시, 공격
				--Tile 또는 PlaceableObject일 때,
						DetectGridPos 호출 후  QuickSlot과 InventoryGrab에서 공통으로 사용하는 GridItemCheck 호출
						좌클릭 시, CheckItemDrop(Inventory) 과 CheckItemUse(QuickSlot) 
						우클릭 시, PlaceableObject의 경우 회전
				--Portion인 경우
						우클릭 시, ItemUse

				--None인 경우
						우클릭 시, PlaceableObject 회수

			따라서 PlayerHand 또한 스크립트 분리가 필요해 보임
				--PlayerHandAction ?
				--PlayerHand가 곧 현재 마우스의 위치에 해당됨

##1014까지 추가사항 및 변경사항
			 PlayerHand에서 ItemType Tool 추가

			 PlayerMouseAction과 PlayerHand 수정 필요
			 Update()의 위치를 고려해야 됨
			 -마우스액션들은 1개의 Update에서 처리해야 됨


			 Plant
				-ScriptableObject
				-작물의 데이터
					--드랍 테이블과 작물의 종류(나무, 야채), 성장기간 등이 저장됨
			 PlantObject
				-MonoBehaviour
				-작물 오브젝트를 위한 부모 클래스
				-IGrowth가 포함되어 날짜가 지날 때 마다 Growth() 호출
				-public virtual void Harvest()가 포함되어 있음 => 일반 작물
				-public virtual void Harvest_Tree() => 나무
				-public virtual void Interaction() => 나무만
				-Growth 시, 나무의 경우 크기 변경
			 IGrowth
				-Interface
				-    public void Growth()가 포함된 인터페이스
			 PlantDB
				-ScriptableObject
				-Plant 데이터베이스

			 FarmSystem
				-아래 추가
				-PlayerHand, PlacementSystem, PlayerMouseAction과 관계되어 있음

			 PlayerMouseAction
				-Tool->Hoe일 때, 경작
				-Resource->Seed 일때 씨앗 심기
				-Tool->Axe 일 때, 나무 벌목
				- Interact=> Tree일 때, Harvest_Tree() => 나무 흔들기
				- Interact=> PlantObject 일 때, Harvest() => 수확

			 FarmSystem 추가
			 PlacementSystem에서 PlaceObject와 같은 방식으로 경작지 구성
				-Farmland Tilemap 추가
					--Farmland Tilemap에 해당되는 땅은 Reclaimed RuleTile로 변경
					--변경된 RuleTile은 PlaceObject와 같은 방식으로 저장

			 Tool에서 Hoe 추가
				-PlayerHand에서 Tool일 때, ToolType이 Hoe인 경우 Reclaim()이 호출됨
					--Reclaim은 위의 Farmland Tilemap과 같음
			 
##1015
			Raycast되는 MousePosition의 거리를 제한 하는 법
			-플레이어 기준으로 마우스 액션의 거리가 제한되어야 함
			-Raycast되는 거리가 제한되는 것이고, 거리에 상관없는 마우스 액션은 제한되지 않음

			normalizedVector = (PlayerPos - MousePos).normalized
			mouseCastPoint = PlayerPos + (normalizedVector * vectorLength)

			코드
			private static RaycastHit2D RayCast(ref Vector3 mousePos, ref LayerMask layer, Camera cam)
			{
				mousePos.z = cam.nearClipPlane;
				RaycastHit2D hit = Physics2D.Raycast(mousePos, cam.transform.forward, 100, layer);
				return hit;
			}
			private static RaycastHit2D MouseRestrictedRaycast(ref Vector3 playerPos, ref LayerMask layer)
			{
				Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				Vector3 normalizedMouse;
				CalculateNormalVector(playerPos, mouseWorldPos, 2f, out normalizedMouse);

				return RayCast(ref normalizedMouse, ref layer, Camera.main);
			}
			public static void CalculateNormalVector(Vector3 player, Vector3 mouse, float length, out Vector3 normalizedMouse)
			{
				Vector3 normalized = Vector3.zero;
				Vector3 dir = (mouse - player).normalized;
				normalized = player + (dir * length);
				normalizedMouse = normalized;
			}
			public static void PlacedObjectInteract()
			{
				Vector3 playerPos = Vector3.zero;   //Debug
				RaycastHit2D hit = MouseRestrictedRaycast(ref playerPos, ref ins.objectLayer);
			}

##1016
			MouseEvent를 체크할 때는
			무조건 GetMouseButtonDowm에서 좌클릭, 우클릭을 먼저 분리하기
			-Tool을 들고 있을 때나, 손에 아무것도 없을 때, Resource를 들고 있을 때, Weapon을 들고있을 때
				모두 우클릭시 Interact()가 되어야 하기 때문에 
				먼저 ItemType을 구분하는 것보다, 클릭을 구분하는게 편하다

			-ItemType을 비트 연산자를 쓸 수 있게 해야됨
			-ItemType을 먼저 구분하고나서 ToolType, WeaponType 등을 구분한다
			-Raycast시, Layer를 비트 연산자로 새롭게 계산해서 한다
				--ex) Tool-Pickage을 들고 있을 때, Plant와 PlaceObject, FieldObject(광석 등) 둘다 체크해야 한다
				--ex2) Resource를 들고 있을 때, Plant(나무의 경우?)와 PlaceObject을 체크한다
				--ex3) Tool-Hoe를 들고 있을 때, Plant와 PlaceObject를 체크한다

			***PlaceObject와 FieldObject는 분리한다
				--PlaceObject => 가구, 플레이어가 설치하는 Interatable Object
				--FieldObject => 필드에서 Spawn되는 Breakable Object
			
