# TIL
 
##1001
###Unity
			ItemDataBase 작성
			ItemDB에 아이템 목록을 작성할 때, Class를 기준으로 넣는 경우
			
			Item.cs
			public class Item : ScriptableObject
			{
				[SerializeField] private int _id;
				public int id { get { return _id; }}
			}

			TileItem.cs
			public class TileItem : Item
			{
				[SerializeField] private TileBase _tile;
				public TileBase tile { get { return _tile; }}
			}

			ItemDB.cs
			public class ItemDB : ScriptableObject
			{
				[SerializeField] private List<Item> _db = new List<Item>();

				public void GetItem(ref int id)
				{
					float index = id;

					//추가적인 서칭 로직
					*
					*
					*

					return _db[index];
				}
			}

			위의 코드로 작성할 경우
			Item과 TileItem의 서로다른 ScriptableObject를 만들 수 있으며,
				ItemDB의 _db에는 둘다 추가할 수 있다

			추가사항
			TileBase 비슷하게 RuleTile도 TileBase에 넣고 typeof로 RuleTile인지 boolCheck


##1003~100(7)	지속적으로 추가
###Unity
			PlaceSystem

			Grid기반
			Mask의 경우 TileMap에 Raycast를 Hit시켜 체크
			-MouseGridPos와 RaycastedGridPos가 있음
			-둘이 불일치하면 불가능한 구역

			만약, 손에 아이템이 있으면
			-손에 있는 아이템이 삽인 경우 => 선택된 Tile의 종류를 체크 => 삽으로 팔 수 있는가?
			-손에 있는 아이템이 곡괭이인 경우 => 선택된 PlaceObject의 종류를 체크 
			-손에 있는 아이템이 괭이인 경우 => 이미 아이템이 배치되어 있는가? => 선택된 Tile이 Mask에 포함되는가? 
								=> Dirt가 맞는가? => 물이 뿌려져 있는가?


			배치에는 여러 종류가 필요
			구분된 배치종류

			다중 레이어로 배치가능 구역 구분
			- Grid--TileMap으로 Farmable, Placeable 구분
			- 단, Farmable의 경우 DirtTile일 때, FarmlandTile로 바꾸는 경우 사용 x
			- Placeable은 각 맵마다 다른 데이터를 사용

			따라서 현재 Mask는
			*Placeable
			*Farmland
			**Fishing ***=> 낚시의 경우 Shovel로 WaterTile로 바뀌는 경우 Mask를 사용하면 바뀐 타일에서 낚시 불가능

			Tile
			-다른씬에 넘어가도 유지필요성 x
			-씬 로드시 SetTile해도 됨
			-특정 타일만 바꿀 수 있을 떄, 바꾸려는 Tile이 바뀔 TileItem에 정보가 있어야됨
				--TileManger에서 TileDataBase를 추가하는 방법도 있음

			Plants
			-다른 씬에 넘어가도 유지되야 함
				--시간에 따른 성장 때문에
				--씬이 Release되어도 DontDestroy에서 동작
				--수확할 때
					---Raycast로 체크, PlaceableObject와 다른 레이어지만, 동시에 처리
			-반드시 농지(farmland)위에 만들어야 함
				--타일에 대한 체크가 필요
				--선택된 타일이 Farmland인지 체크 + 이미 Plant가 있는지 체크 
			-나무의 경우 3X3등의 넓은 타일 사용가능
			-물뿌리개를 들고있는 경우 Farmland기준으로 체크


			PlaceableObject
			-다른 씬에 넘어가도 유지되야 함
				--제작하는 오브젝트가 있음
				--씬이 Release되어도 DontDestroy에서 동작
			-최대 숫자 제한이 필요
			-메모리상 차지하는 공간의 크기도 고려되어야 함 => DontDestroy에 있기 때문


			오브젝트의 저장
			-오브젝트의 종류에 따른 다른 저장
			-Placeable의 경우 크기가 각색이기 때문에, GridPos와 ItemID 또는 ObjectID만 저장
				--로드시 배치할 때와 같은 로직으로 배치 => 같은 결과
				--그리드는 1칸의 중앙은 Vector2(.5f, .5f)가 더해져야 됨
